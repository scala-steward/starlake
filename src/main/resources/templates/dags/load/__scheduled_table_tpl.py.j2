from ai.starlake.orchestration import StarlakeSchedules, StarlakeSchedule, StarlakeDomain, StarlakeTable, StarlakeOrchestrationFactory

schedules= [{% for schedule in context.schedules %}
    StarlakeSchedule(
        name='{{ schedule.schedule }}', 
        cron={% if schedule.cron is not none %}'{{ schedule.cron }}'{% else %}None{% endif %}, 
        domains=[{% for domain in schedule.domains %}
            StarlakeDomain(
                name='{{ domain.final_name }}', 
                final_name='{{ domain.final_name }}', 
                tables=[{% for table in domain.tables %}
                    StarlakeTable(
                        name='{{ table.final_name }}', 
                        final_name='{{ table.final_name }}'
                    ){% if not loop.last  %},{% endif %}{% endfor %}
                ]
            ){% if not loop.last  %},{% endif %}{% endfor %}
    ]){% if not loop.last  %},{% endif %}{% endfor %}
]

def generate_pipelines():
    with StarlakeOrchestrationFactory.create_orchestration(job=sl_job) as orchestration:

        def generate_pipeline(schedule: StarlakeSchedule):
            # generate the load pipeline
            schedule_pipeline = orchestration.sl_create_schedule_pipeline(
                schedule, 
                len(schedules)
            )
            schedule_name = schedule_pipeline.sl_schedule_name

            with schedule_pipeline as pipeline:

                start = pipeline.sl_start()

                pre_tasks = pipeline.sl_pre_tasks()

                if pre_tasks:
                    pipeline.sl_add_dependency(start, pre_tasks)

                def generate_load_domain(domain: StarlakeDomain):

                    from ai.starlake.common import sanitize_id

                    if schedule_name:
                        name = f"{domain.name}_{schedule_name}"
                    else:
                        name = domain.name

                    with pipeline.sl_create_task_group(group_id=sanitize_id(name)) as load_domain:
                        pld = pipeline.sl_pre_load(
                            domain=domain.name, 
                            tables=set([table.name for table in domain.tables]), 
                            params={'cron':schedule.cron},
                        )
                        with pipeline.sl_create_task_group(group_id=sanitize_id(f'load_{name}')) as load_domain_tables:
                            for table in domain.tables:
                                load_domain_tables.sl_add_task(
                                    pipeline.sl_load(
                                        task_id=sanitize_id(f'load_{domain.name}_{table.name}'), 
                                        domain=domain.name, 
                                        table=table.name,
                                        spark_config=None,
                                        params={'cron':schedule.cron},
                                    )
                                )

                        if pld:
                            load_domain.sl_add_task(pld)
                            pipeline.sl_add_dependency(pld, load_domain_tables)

                        load_domain.sl_add_task(load_domain_tables)

                    return load_domain

                load_domains = [generate_load_domain(domain) for domain in schedule.domains]

                end = pipeline.sl_end(cron=schedule.cron)

                for ld in load_domains:
                    if pre_tasks:
                        pipeline.sl_add_dependency(pre_tasks, ld)
                    else:
                        pipeline.sl_add_dependency(start, ld)
                    pipeline.sl_add_dependency(ld, end)

                post_tasks = pipeline.sl_post_tasks()
            
                if post_tasks:
                    all_done = pipeline.sl_dummy_op(task_id="all_done")
                    for ld in load_domains:
                        pipeline.sl_add_dependency(ld, all_done)
                    pipeline.sl_add_dependency(all_done, post_tasks)
                    pipeline.sl_add_dependency(post_tasks, end)

            return pipeline

        return [generate_pipeline(schedule) for schedule in schedules]

generate_pipelines()
